
var ryver = require('ryver');
var p = require('path');
var fs = require('fs.extra');
var eventEC = ryver.eventEC;
var async = require('async');

var originMasterFileURLs = {}
var originFileURLs = {}

eventEC.onCollect( 'watch', function( cb ){

  function deleteTracesOfMaster( URL, cb ){

    // The file might or might not have any destination file.
    // If it doesn't, the array will be empty and async will
    // simply do nothing (except skip to the final callback)
    var toUnlink = originMasterFileURLs[ URL ] || [];

    async.each(

      toUnlink,

      function( destFileURL, cb ){
        ryver.log("Deleting destination: ", p.join( ryver.getDst(), destFileURL ) );

        fs.unlink( p.join( ryver.getDst(), destFileURL ), cb );
      },

      function( err ){
        if( err ) return cb( err );

        ryver.log("Deleting entry", URL, "from originMasterFileURL");

        // Delete the entry from originMasterFileURLs
        delete originMasterFileURLs[ URL ];

        ryver.log("Looking for ", URL, "in originFileURLs (as possible value in array)" );

        // Delete the entry from originFileURLs
        // This is trickier as the file could be LISTED anywhere as an index
        Object.keys( originFileURLs ).forEach( function( originFileURL ){
          originFileURLs[ originFileURL ] = originFileURLs[ originFileURL ].filter(
            function( affectedOriginFileURL ){
              return URL !== affectedOriginFileURL;
            }
          );
          if( originFileURLs[ originFileURL ].length === 0 ){
            delete originFileURLs[ originFileURL ];
          }
        });

        ryver.vlog("originFileURLs AFTER DELETION: ", originFileURLs );
        cb( null );
      }
    );

  }


  function refilter( URL, cb ){

    if( originFileURLs[ URL ] ){
      ryver.log("Files affected by the change:", originFileURLs[ URL ] );

      // List of origin files to refilter.
      var toRefilter = originFileURLs[ URL ];

      ryver.log("Deleting previouly copied files." );

      // Always delete traces, since it will be re-filtered anyways
      deleteTracesOfMaster( URL, function( err ){
        if( err ) return cb( err );

        async.each(

          toRefilter,

          function( originFileURL, cb ){

            var finalYaml = ryver.yamlFromFileURL( originFileURL );

            ryver.makeFileData( originFileURL, p.dirname( originFileURL ), p.basename( originFileURL), null, finalYaml, function( err, fileData ){
              if( err ) return cb( err );

              ryver.vlog("Created fileData:", ryver.trimFileData( fileData ) );

              // Add the file itself to the list of origins since it IS a file on the file system
              fileData.system.originFileURLs.push( originFileURL );

              // Do the filtering, and that's it!
              ryver.filter( fileData, cb );

            });

          },

          function( err ){
            if( err ) return cb( err );

            ryver.log( "Filtering delayed items..." );

            // Filter delayed items, and thats it.
            ryver.filterDelayedItems( cb );
          }
        );

      });
    }
  }

  var f = function( op, URL, cb ){
    ryver.log( "filecopy-watch: Operation", op, "on", URL );

    ryver.vlog("originMasterFileURLs:", originMasterFileURLs );
    ryver.vlog("originFileURLs: ", originFileURLs );

    // If a file gets deleted, delete all of its generated results
    if( op === 'unlink' ){
      deleteTracesOfMaster( URL, cb );
    }

    // If a file is added or changed, look for it
    if( op === 'add' || op === 'change') {
      refilter( URL, cb );
    }
  }

  // Return the function just defined as the filter
  cb( null, { name: 'filecopy-watch', executor: f } );
});

// filecopy

eventEC.onCollect( 'afterEverything', function( cb ){

  var f = function( fileData, cb ){

    // If the file is to be dropped, goodbye
    if( fileData.info.drop ) return cb( null );

    ryver.vlog( "Full file path is", fileData.system.filePath );

    // Make up the full destination of the file relative to `dst`
    var fullDest = p.join( ryver.getDst(), fileData.system.filePath );

    ryver.vlog( "Final destination, with `dst` in front is ", fullDest );

    // Make the containing directory in the destination folder
    fs.mkdirp( p.join( fullDest ), function( err ){
      if( err ) return cb( err );

      var s = fileData.system;
      fs.writeFile( p.join( fullDest, s.fileName + s.fileExt ), fileData.contents, function( err ){
        if( err ) return cb( err );

        var originMasterFileURL = fileData.system.originMasterFileURL;

        // This will only happen if there IS an origin master file (that is,
        // if the filter is the result of a file that is actually in the source
        // file system
        if( originMasterFileURL && ryver.getWatch() ) {

          // Creates an entry in originMasterFileURL if needed.
          // It will map the originMasterFileURL to the actually created files, so that
          // deletion of the source for example will lead to deletion of all resulting files
          originMasterFileURLs[ originMasterFileURL ] = originMasterFileURLs[ originMasterFileURL ] || [];
          originMasterFileURLs[ originMasterFileURL ].push( p.join( fileData.system.filePath, s.fileName + s.fileExt ) );

          // Each origin will have a list of "dependent" files, which will be
          // affected by the change
          fileData.system.originFileURLs.forEach( function( originFileURL ){
            originFileURLs[ originFileURL ] = originFileURLs[ originFileURL ] || [];
            if( originFileURLs[ originFileURL ].indexOf( originMasterFileURL ) === -1 )
              originFileURLs[ originFileURL ].push( originMasterFileURL );
          });
        }

        cb( null );
      });

    });
  }

  // Return the function just defined as the filter
  cb( null, { name: 'filecopy', executor: f } );
});
