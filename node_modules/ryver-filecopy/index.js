
var ryver = require('ryver');
var p = require('path');
var fs = require('fs.extra');
var eventEC = ryver.eventEC;
var async = require('async');

var originMasterFileURLs = {}
var originFileURLs = {}


eventEC.onCollect( 'watch', function( cb ){

  var f = function( op, URL, cb ){
    console.log( "filecopy-watch: Operation", op, "on", URL );

    console.log("originMasterFileURLs:", originMasterFileURLs );
    console.log("originFileURLs: ", originFileURLs );

    // If a file gets deleted, delete all of its generated results
    if( op === 'unlink' ){

      // The file might or might not have any destination file.
      // If it doesn't, the array will be empty and async will
      // simply do nothing (except skip to the final callback)
      var toUnlink = originMasterFileURLs[ URL ] || [];

      async.each(

        toUnlink,

        function( destFileURL, cb ){
          console.log("AH! Deleting: ", p.join( ryver.getDst(), destFileURL ) );

          fs.unlink( p.join( ryver.getDst(), destFileURL ), cb );
        },

        function( err ){
          if( err ) return cb( err );

          console.log("Deleting entry", URL, "from originMasterFileURL");

          // Delete the entry from originMasterFileURLs
          delete originMasterFileURLs[ URL ];

          console.log("Looking for ", URL, "in originFileURLs (as possible value in array)" );

          // Delete the entry from originFileURLs
          // This is trickier as the file could be LISTED anywhere as an index
          Object.keys( originFileURLs ).forEach( function( originFileURL ){
            originFileURLs[ originFileURL ] = originFileURLs[ originFileURL ].filter(
              function( affectedOriginFileURL ){
                return URL !== affectedOriginFileURL;
              }
            );
            if( originFileURLs[ originFileURL ].length === 0 ){
              delete originFileURLs[ originFileURL ];
            }
          });

          console.log("originFileURLs AFTER DELETION: ", originFileURLs );

          cb( null );
        }
      );
    }


    // If a file is added or changed, look for it
    if( op === 'add' || op === 'change') {
      if( originFileURLs[ URL ] ){
        console.log("AH! Files affected by the change: ", originFileURLs[ URL ] );

        // For EACH entry in originFileURLs[ URL ], work out final info.yaml
        // and re-run filtering

      }

    }

    cb( null );
  }

  // Return the function just defined as the filter
  cb( null, { name: 'filecopy-watch', executor: f } );
});

// filecopy

eventEC.onCollect( 'afterEverything', function( cb ){

  var f = function( fileData, cb ){

    // If the file is to be dropped, goodbye
    if( fileData.info.drop ) return cb( null );

    ryver.vlog( "Full file path is", fileData.system.filePath );

    // Make up the full destination of the file relative to `dst`
    var fullDest = p.join( ryver.getDst(), fileData.system.filePath );

    ryver.vlog( "Final destination, with `dst` in front is ", fullDest );

    // Make the containing directory in the destination folder
    fs.mkdirp( p.join( fullDest ), function( err ){
      if( err ) return cb( err );

      var s = fileData.system;
      fs.writeFile( p.join( fullDest, s.fileName + s.fileExt ), fileData.contents, function( err ){
        if( err ) return cb( err );

        var originMasterFileURL = fileData.system.originMasterFileURL;

        // This will only happen if there IS an origin master file (that is,
        // if the filter is the result of a file that is actually in the source
        // file system
        if( originMasterFileURL && ryver.getWatch() ) {

          // Creates an entry in originMasterFileURL if needed.
          // It will map the originMasterFileURL to the actually created files, so that
          // deletion of the source for example will lead to deletion of all resulting files
          originMasterFileURLs[ originMasterFileURL ] = originMasterFileURLs[ originMasterFileURL ] || [];
          originMasterFileURLs[ originMasterFileURL ].push( p.join( fileData.system.filePath, s.fileName + s.fileExt ) );

          // Each origin will have a list of "dependent" files, which will be
          // Creates an entry in originFileURLsInFileData if needed.
          // affected by the change
          var originFileURLsInFileData = fileData.system.originFileURLs;
          originFileURLsInFileData.forEach( function( originFileURL ){
            originFileURLs[ originFileURL ] = originFileURLs[ originFileURL ] || [];
            if( originFileURLs[ originFileURL ].indexOf( originMasterFileURL ) === -1 )
              originFileURLs[ originFileURL ].push( originMasterFileURL );
          });
        }

        console.log("File written:", p.join( fullDest, s.fileName + s.fileExt ) );
        console.log( ryver.trimFileData( fileData ) );

        cb( null );
      });

    });
  }

  // Return the function just defined as the filter
  cb( null, { name: 'filecopy', executor: f } );
});
