
var ryver = require('ryver');
var p = require('path');
fs = require('fs.extra');

var eventEC = ryver.eventEC;

var groupData = {};
var DO = require( 'deepobject');

// grouper -- information gathering for grouper
eventEC.onCollect( 'filter', function( cb ){

  var f = function( fileData, cb ){

    // If it has listLatest, it will force the file to fileData.info.delayPostProcess
    if( fileData.info.listLatest ){
      fileData.info.delayPostProcess = true;
    }

    // Initialise _ALL_ if needed
    groupData._ALL_ = groupData._ALL_ || [];

    // If it's not "listed", then it won't be in the picture at all
    if( ! fileData.info.listed ) return cb( null, fileData );

    // Add file to the main list of all files
    groupData._ALL_.push( fileData );

    // listVars will have the list of "grouping variables",
    // e.g. 'tags', 'category'
    var listVars = ryver.getConfig().listVars;

    // No grouping to do for this file
    if( typeof listVars !== 'object') return cb( null, fileData );

    var groups = Object.keys( listVars );

    // For each groupingVar set in the config, check if there's a
    // fileata.info[ group ] in the file's data -- if so, it will represent
    // a list of "values"
    groups.forEach( function( group ){
      if( ! fileData.info[ group ] ) return;

      // Initialise groupData for that group if needed
      groupData[ group ] = groupData[ group ] || {};

      // Get group values as an array
      var groupValues = fileData.info[ group ].split( ',' );
      if( groupValues.length === 1 && groupValues[ 0 ] == '' ) return;

      groupValues.forEach( function( value ){
        groupData[ group ] [ value ] = groupData[ group ] [ value ] || [];
        groupData[ group ] [ value ].push( fileData );
      })
    })

    return cb( null, fileData );
  }

  // Return the function just defined as the filter
  cb( null, { name: 'grouper', executor: f } );
});

// Before running the delayed postProcessFilters, it will
// make sure that data is properly sorted
eventEC.onCollect( 'beforeDelayedPostProcess', function( cb ){

  var f = function( cb ){

    var makeSorter = function( sortField ){
      return function( a, b ){
        if( a.info[ sortField ] === b.info[ sortField ] ) return 0;
        if( a.info[ sortField ] >   b.info[ sortField ] ) return 1;
        if( a.info[ sortField ] >   b.info[ sortField ] ) return -1;
      }
    };

    // Sort the main (FULL) list of pages
    if( groupData._ALL_ ){
      groupData._ALL_.sort( ryver.getConfig().listAll.sortBy );
    }

    // Sort the sub-lists, if they are to be sorted
    var config = ryver.getConfig().listVars;
    Object.keys( groupData ).forEach( function( list ){
      if( list === '_ALL_' ) return;
      var sortField = config[ list ].sortBy;
      Object.keys( groupData[ list ] ).forEach( function( value ){
        groupData[ list ] [ value ].sort( makeSorter( sortField ) );
      })
    });

    cb( null );
  }

  // Return the function just defined as the filter
  cb( null, f );
});

// grouper-vars -- generating variables based on the gathered variables.
//                 To be run ONLY if fileData.info.delayPostProcess is set
//                 to true, or groupData is obviously incomplete
//                 This has things like "latest 10 blog entries", etc.
eventEC.onCollect( 'filter', function( cb ){

  var f = function( fileData, cb ){

    if( fileData.info.listLatest && ! fileData.info.delayPostProcess ){
      return cb( new Error( "You need to set delayPostProcess to true if you want to use listLatest" ));
    }

    // This will only work if postProcess was delayed
    if( ! fileData.info.listLatest ){
      ryver.log( "listLatest isn't set, nothing to do")
      return cb( null, fileData );
    }

    ryver.log( "Setting listLatest variables");

    // Make up fileData.info.listLatestData based on fileData.info.listLatest
    // The data will be taken from groupData
    fileData.info.listLatestData = {};
    for( var list in fileData.info.listLatest ){

      // Setting `data` and `howMany`
      var data = DO.get( groupData, list ) || [];
      var howMany = fileData.info.listLatest[ list ];

      fileData.info.listLatestData[ list ] = data.slice( 0, howMany - 1 );
    };

    console.log("INFO AFTER: ", fileData.info );
    return cb( null, fileData );
  }

  // Return the function just defined as the filter
  cb( null, { name: 'grouper-vars', executor: f } );
});


// grouper -- afterFilter to generate lists
eventEC.onCollect( 'afterDelayedPostProcess', function( cb ){

  var f = function( cb ){
    //console.log("DATA IS:", require('util').inspect( groupData, { depth: 10 }  ) );

    console.log("DATA IS:", groupData._ALL_.length );

    // TODO

    return cb( null );
  }

  // Return the function just defined as the filter
  cb( null, f );
});
