
var ryver = require('ryver');
var p = require('path');
fs = require('fs.extra');

var eventEC = ryver.eventEC;

var groupData = {};

// grouper -- information gathering for grouper
eventEC.onCollect( 'filter', function( cb ){

  var f = function( fileData, cb ){

    var groupingVars = ryver.getConfig().groupingVars;

    // No grouping to do for this file
    if( typeof groupingVars !== 'object') return cb( null, fileData );

    var groups = Object.keys( groupingVars );

    groupData._ALL_ = groupData._ALL_ || [];
    groupData._ALL_.push( fileData );

    groups.forEach( function( group ){
      if( ! fileData.info[ group ] ) return;

      // Get group values as an array
      var groupValues = fileData.info[ group ].split( ',' );
      if( groupValues.length === 1 && groupValues[ 0 ] == '' ) return;

      // Initialise groupData if needed
      groupData[ group ] = groupData[ group ] || {};

      groupValues.forEach( function( value ){
        groupData[ group ] [ value ] = groupData[ group ] [ value ] || [];
        groupData[ group ] [ value ].push( fileData );
      })
    })

    return cb( null, fileData );
  }

  // Return the function just defined as the filter
  cb( null, { name: 'grouper', executor: f } );
});

// Before running the delayed postProcessFilters, it will
// make sure that data is properly sorted
eventEC.onCollect( 'beforeDelayedPostProcess', function( cb ){

  var f = function( cb ){

    var makeSorter = function( sortField ){
      return function( a, b ){
        if( a.info[ sortField ] === b.info[ sortField ] ) return 0;
        if( a.info[ sortField ] >   b.info[ sortField ] ) return 1;
        if( a.info[ sortField ] >   b.info[ sortField ] ) return -1;
      }
    };

    // Sort the main (FULL) list of pages
    if( groupData._ALL_ ){
      groupData._ALL_.sort( ryver.getConfig().groupingVarsAll.sortBy );
    }

    // Sort the sub-lists, if they are to be sorted
    var config = ryver.getConfig().groupingVars;
    Object.keys( groupData ).forEach( function( group ){
      if( group === '_ALL_' ) return;
      var sortField = config[ group ].sortBy;
      Object.keys( groupData[ group ] ).forEach( function( value ){
        groupData[ group ] [ value ].sort( makeSorter( sortField ) );
      })
    });

    cb( null );
  }

  // Return the function just defined as the filter
  cb( null, f );
});

// grouper-vars -- generating variables based on the gathered variables.
//                 To be run ONLY if fileData.info.delayPostProcess is set
//                 to true, or groupData is obviously incomplete
//                 This has things like "latest 10 blog entries", etc.
eventEC.onCollect( 'filter', function( cb ){

  var f = function( fileData, cb ){

    // This will only work if postProcess was delayed
    if( ! fileData.info.delayPostProcess ){
      ryver.log( "Processing wasn't delayed. This filter won't work. Skipping.")
      return cb( null, fileData );
    }

    ryver.log( "Processing was delayed. Setting variables");

    // Add grouping and latest to fileInfo
    fileData.info.grouping = {};
    fileData.info.grouping.latest = {};

    // TODO
    // Assign values to fileData.info.grouping.latest[ group ][value]
    // BUT, only _ALL_ and the ones that to be done

    return cb( null, fileData );

  }

  // Return the function just defined as the filter
  cb( null, { name: 'grouper-vars', executor: f } );
});


// grouper -- afterFilter to generate lists
eventEC.onCollect( 'afterDelayedPostProcess', function( cb ){

  var f = function( cb ){
    //console.log("DATA IS:", require('util').inspect( groupData, { depth: 10 }  ) );

    console.log("DATA IS:", groupData._ALL_.length );

    // TODO

    return cb( null );
  }

  // Return the function just defined as the filter
  cb( null, f );
});
