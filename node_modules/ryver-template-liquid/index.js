
var ryver = require('ryver');
var liquid = require('tinyliquid');
var p = require('path');
var fs = require('fs.extra')

var eventEC = ryver.eventEC;

eventEC.onCollect( 'filter', function( cb ){

  var f = function( fileData, cb ){

    // This filter will only work on text files (of any kind)
    if( fileData.system.mimetype.split('/')[0] !== 'text'){
      ryver.log( "File ignored as mime type is not 'text':", fileData.system.mimetype );
      return cb( null, fileData);
    }

    var render = liquid.compile( fileData.contents,
      {
        customTags: {
          say_hello: function (context, name, body) {
            // the first argument is the current parser context, different with tinyliquid.newContext()
            // the second argument is the current tag name, in this example is "say_hello"
            // the third argument is the tag content, in this example is "name"
            // use context.astStack.push(ast) to add the results to the AST tree
            // so we can convert the custom tag to the base tag template => Hello, {{name}}!
            // and use tinyliquid.parse() to get the results
            var ast = liquid.parse('Hello, ' + body.trim() + '! ');


            context.astStack.push(ast);
          }
        }
      }
    );

    var context = liquid.newContext ({
      locals : fileData,
    });

    // Define onInclude so that `include` works
    context.onInclude( function( name, cb ){
      fs.readFile( p.join( fileData.system.filePath, name ), 'utf-8', function( err, included ){
        if( err ) return cb( err );

        var ast = liquid.parse( included );
        cb( null, ast );
      });
    });

    // Render the file using the created context
    render( context, function( err ){
      if( err ) return cb( err );

      fileData.contents = context.getBuffer();
      cb( null, fileData );
    });
  }

  // Return the function just defined as the filter
  cb( null, { name: 'template-liquid', executor: f } );
});
