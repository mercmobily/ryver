#!/usr/bin/env node

/**
 * Dependencies.
 */

var ryver = require('..');
var program = require('commander');
var chalk = require('chalk');
var yaml = require('js-yaml');
var async = require('async');

var fs = require('fs');
var p = require('path');

var static = require('node-static');

/**
 * Support functions.
 */

function pathIsExistingDir( path ){
  try {
    return fs.lstatSync( path ).isDirectory();
  } catch ( e ){
    fatal( e );
  }
}


function fatal(msg, stack){
  console.error();
  console.error(chalk.red('  Ryver') + chalk.gray(' · ') + msg);
  if (stack) {
    console.error();
    console.error(chalk.gray(stack));
  }
  console.error();
  process.exit(1);
}


function log( message ){
  console.log();
  console.log( chalk.gray('  Ryver · ') + message );
  console.log();
}

function serveFiles(){
  var port = program.port || 8080;

  var finalhandler = require('finalhandler')
  var http = require('http')
  var serveStatic = require('serve-static')

  // Serve up public/ftp folder
  var serve = serveStatic( dst, { fallthrough: false, 'index': ['index.html', 'index.htm']})

  // Create server
  var server = http.createServer(function( req, res ){
    var done = finalhandler( req, res)
    serve( req, res, function( err ){
      if( err ){
        if( err.status === 404 ) console.err( "File not found:", err.path );
        else console.log( "Server error:", err );
      }
      done( err );
    });
  })

  // Listen
  server.listen( port );
  console.log("Site is available on http://localhost:" + port)
}

function watchFiles(){
  console.log("Watching files and re-generating in real time" );

  var watchers = [];
  var queue = [];

  ryver.eventEC.emitCollect( 'watch', function( err, watchersResults ){
    if( err ) return cb( err );

    // Gather the list of executors
    watchersResults.onlyResults().forEach( function( watcher ) {
      watchers.push( { name: watcher.name, executor: watcher.executor } );
    });


    // Run the watcher, adding an 'ignore' option for the destination directory
    // in case it's within the source one
    function stripTrailingSlash( str ){
      return str.substr( -1 ) === '/' ? str.substr(0, str.length - 1 ) : str;
    }
    var chokidar = require('chokidar');
    var fileWatcher = chokidar.watch( src, {
      persistent: true,
      ignored: stripTrailingSlash( ryver.getDst() ),
    });

    fileWatcher
      .on('error', function(error) { log('Error happened', error); })
      .on('ready', function() {

        // I don't think I am interested in these ones
        //watcher.on('addDir', function( path ) { log('Directory', path, 'has been added'); })
        //watcher.on('unlinkDir', function( path ) { log('Directory', path, 'has been removed'); })
        //watcher.on('raw', function(event, path, details) { log('Raw event info:', event, path, details); })

        // Makes the returning function, depending on the event name
        var makeCaller = function( event ){
          return function( path ){
            var URL = path.substr( ryver.getSrc().length + 1 );
            console.log('File', URL, 'had a file system event', event, 'on path', path );

            // Filter out events on the same files already in the queue
            queue = queue.filter( function( element) { return element.URL !== URL } );

            // Add element to th3e queue
            queue.push( { op: event, URL: URL })
          }
        }

        fileWatcher.on('add', makeCaller( 'add' ) );
        fileWatcher.on('change', makeCaller( 'change' ) );
        fileWatcher.on('unlink', makeCaller( 'unlink' ) );

        ryver.log('Initial scan complete. Ready for changes.');
      });

    var running = false;
    setInterval( function(){

      if( !queue.length ) return;

      if( running ){
        ryver.log("There are changes but previous changes are still being dealt with, will wait!" );
      }

      // Destructive copy of queue onto the q variable
      var q = queue.splice( 0, queue.length );

      // For each element in the queue...
      async.eachSeries(
        q,
        function( qEntry, cb ){
          ryver.log("Dealing with entry in queue:", qEntry );
          ryver.log("Number of watchers:", watchers.length );

          // Goes through the watchers, and execute them
          async.eachSeries(
            watchers,
            function( watcher, cb ){
              ryver.log("Executing watcher:", watcher.name );

              watcher.executor.call( this, qEntry.op, qEntry.URL, cb );
            },
            function( err ){
              if( err ) return cb( err );
              cb( null );
            }
          )
        },
        function( err ){
          running = 0;
          if( err ) console.log("Error!", err );
        }
      )



    }, 2000 );

  });

}

/**

 * Usage.
 */

program
  .version(require('../package.json').version)
  .usage("[options] [source] [destination]")
  .option('-P, --plugins [plugins]', 'Set plugins to load')
  .option('-v, --verbose', 'Verbose output')
  .option('-x, --extra-verbose', 'Very verbose output')
  .option('-s, --serve', 'Serve site after building')
  .option('-p, --port [port]', 'If serving a site, which port to use (default: 8080)')
  .option('-w, --watch', 'Watch for file changes after building');

/**
 * Examples.
 */

program.on('--help', function(){
  console.log('  Examples:');
  console.log();
  console.log('    # build using current directory as source, and ./_site as destinaton"');
  console.log('    $ ryver');
  console.log();
  console.log('    # build using /home/m/source as source, and and /home/m/source/_site as destinaton"');
  console.log('    $ ryver /home/m/source');
  console.log();
  console.log('    # build using /home/m/source as source, and and /home/m/site as destinaton"');
  console.log('    $ ryver /home/m/source /home/m/site');
  console.log();
  console.log('    # build loading the plugin "ryver-extrafilter" dynamically');
  console.log('    $ ryver -p /home/m/source /home/m/site');
  console.log();

});

/**
 * Parse and get parameters.
 */

program.parse( process.argv );

var cwd = process.cwd();
var src = program.args[ 0 ] || '.';
var dst = program.args[ 1 ] || './_site';

pathIsExistingDir( src );
pathIsExistingDir( dst );

ryver.setSrc( src );
ryver.setDst( dst );

// Set verbosty level
if( program.verbose ) ryver.setVerbose( 1 );
else if( program.extraVerbose ) ryver.setVerbose( 2 );

// Set the internal watch variable
if( program.watch ) ryver.setWatch( true );

/**
 * Load plugins.
 */

// Default plugins
var plugins = [ 'frontmatter', 'pager', 'markup-markdown', 'layout', 'landing', 'lister', 'template-liquid', 'template-ejs', 'filecopy'  ];

// Add plugin from "master" _info.yaml file

ryver.readAndSetConfig( function( err, config ){
  if( err ) fatal( err, err.stack );

  var plugins;
  // Take plugins from the command line (which takes precedence) or the config
  // file (as a last resort to change the default list);
  if( program.plugins && program.plugins != '' ){
    plugins = program.plugins.split( ',' );
  } else {
    if( config.plugins && config.plugins != '' ){
      plugins = config.plugins.split( ',' );
    }
  }

  // Load all plugins, which are the module named 'ryver' plus the plugin name
  plugins.forEach( function( plugin ){
    require( 'ryver-' + plugin );
  });

  // This will enrich ryver's internal variables
  // to pre-store the full list of all available filters
  // as well as all available hooks
  ryver.collectFiltersAndHooks( function( err ){
    if( err ) return fatal( err.message, err.stack );

    // Let the fun begin!
    ryver.build( function( err ){
      if( err ) return fatal( err.message, err.stack );

      // If the serve option is on, serve the files
      if( program.serve) {

        serveFiles();
      }
      if( program.watch ){
        watchFiles();
      }

      // That's it: end of story.
      //process.exit();
    });
  })
});
